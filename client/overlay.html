<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CONU Overlay</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: transparent;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
    }

    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }

    .control-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      bottom: auto;
      left: auto;
      width: 420px;
      height: 60px;
      transform-origin: top right;
      /* Glass effect with gradient for depth */
      background: linear-gradient(
        145deg,
        rgba(50, 50, 55, 0.75) 0%,
        rgba(35, 35, 40, 0.8) 100%
      );
      backdrop-filter: blur(40px) saturate(150%);
      -webkit-backdrop-filter: blur(40px) saturate(150%);
      border-radius: 30px;
      /* Light top edge, darker bottom for 3D pop */
      border-top: 1px solid rgba(255, 255, 255, 0.25);
      border-left: 1px solid rgba(255, 255, 255, 0.15);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
      border-bottom: 1px solid rgba(0, 0, 0, 0.3);
      /* Layered shadows for popped-out effect */
      box-shadow:
        0 10px 40px rgba(0, 0, 0, 0.4),
        0 2px 8px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      z-index: 2;
      pointer-events: auto;
      padding: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    /* Bottom-right position mode - expands upward */
    .control-panel.position-bottom {
      top: auto;
      bottom: 20px;
      transform-origin: bottom right;
    }

    /* Sheen effect */
    .control-panel::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.15) 50%, transparent 100%);
      transform: translateX(-150%) skewX(-20deg);
      animation: liquid-sheen 4s ease-in-out infinite;
      pointer-events: none;
    }

    .control-panel.loading-text {
      width: 150px !important;
      height: 50px !important;
      border-radius: 25px !important;
      animation: glow-pulse 2s ease-in-out infinite;
    }

    .control-panel.state-processing {
      animation: glow-pulse 2s ease-in-out infinite;
    }

    /* Loading text display - matches placeholder styling */
    .loading-text-display {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.6);
      font-size: 16px;
      font-weight: 300;
      letter-spacing: 0.3px;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease-in-out;
    }

    .control-panel.loading-text .loading-text-display {
      opacity: 1;
    }

    @keyframes liquid-sheen {

      0%,
      40% {
        transform: translateX(-150%) skewX(-20deg);
      }

      100% {
        transform: translateX(150%) skewX(-20deg);
      }
    }

    @keyframes glow-pulse {

      0%,
      100% {
        box-shadow: 0 4px 16px 0 rgba(0, 0, 0, 0.3);
      }

      50% {
        box-shadow: 0 0 30px 5px rgba(255, 255, 255, 0.4), 0 0 15px 2px rgba(255, 255, 255, 0.3);
      }
    }

    /* Status bar - hidden */
    .status-bar {
      display: none;
    }

    textarea {
      width: 100%;
      height: 60px;
      /* Default height */
      line-height: 20px;
      /* Normal line height for multiline */
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.85);
      font-size: 16px;
      font-weight: 300;
      letter-spacing: 0.3px;
      /* Slightly smaller font */
      resize: none;
      outline: none;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      padding: 20px 25px 20px 25px;
      /* Vertical padding 20px for centering (60px height - 20px line height) / 2 */
      text-align: left;
      /* Left align text */
      transition: all 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      /* Smoother easing */
      overflow-y: hidden;
      /* Hide scrollbar, we'll expand instead */
      box-sizing: border-box;
    }

    .control-panel.loading-text textarea {
      opacity: 0;
      font-size: 0;
      pointer-events: none;
      /* Disable interaction during loading */
    }

    /* Loading icon - hidden, using text instead */
    .loading-icon {
      display: none;
    }


    textarea::placeholder {
      color: rgba(255, 255, 255, 0.6);
      font-weight: 300;
      letter-spacing: 0.3px;
    }

    /* Mouse event log - hidden for now */
    .event-log {
      display: none;
    }

    .event-log-entry {
      margin-bottom: 4px;
      white-space: nowrap;
    }

    .event-log-entry .timestamp {
      color: #666;
    }

    .event-log-entry .event-type {
      color: #8e8e93;
      font-weight: bold;
    }

    .event-log-entry .coords {
      color: #ffff00;
    }

    /* Scroll indicator */
    .scroll-indicator {
      position: absolute;
      left: 50%;
      bottom: 40px;
      transform: translateX(-50%);
      z-index: 3;
      pointer-events: none;
      width: 48px;
      /* Slightly larger for visibility */
      height: 48px;
      /* Slightly larger for visibility */
      background: rgba(142, 142, 147, 0.2);
      /* Grey background */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: pulse-background-grey 2s infinite ease-in-out;
    }

    .scroll-arrow-svg {
      width: 60%;
      /* SVG size relative to container */
      height: 60%;
      filter: invert(50%) sepia(0%) saturate(0%) hue-rotate(0deg) brightness(150%) contrast(100%);
      /* Make SVG grey/white */
      animation: bounce-svg 2s infinite;
    }

    @keyframes bounce-svg {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0);
      }

      40% {
        transform: translateY(6px);
      }

      60% {
        transform: translateY(3px);
      }
    }

    @keyframes pulse-background-grey {
      0% {
        background: rgba(142, 142, 147, 0.2);
        box-shadow: 0 0 10px rgba(142, 142, 147, 0.2);
      }

      50% {
        background: rgba(142, 142, 147, 0.4);
        box-shadow: 0 0 20px rgba(142, 142, 147, 0.5);
      }

      100% {
        background: rgba(142, 142, 147, 0.2);
        box-shadow: 0 0 10px rgba(142, 142, 147, 0.2);
      }
    }

    .instruction-box {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px) saturate(180%);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
      z-index: 3;
      /* Higher than control-panel */
      pointer-events: auto;
      color: white;
      display: flex;
      flex-direction: column;
      padding: 15px;
    }

    .instruction-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
    }

    .instruction-done-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 4px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      transition: background 0.2s;
    }

    .instruction-done-btn:hover {
      background: rgba(255, 255, 255, 0.4);
    }

    .instruction-body {
      flex-grow: 1;
      font-size: 16px;
      line-height: 1.5;
      margin-bottom: 15px;
    }

    .instruction-footer {
      display: flex;
      justify-content: space-between;
    }

    .instruction-nav-btn {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
      width: 48%;
    }

    .instruction-nav-btn:hover {
      background: rgba(255, 255, 255, 0.3);
    }
  </style>
</head>

<body>
  <canvas id="overlay-canvas"></canvas>

  <!-- Control Panel -->
  <div class="control-panel" id="controlPanel">
    <div class="loading-text-display" id="loadingTextDisplay"></div>
    <textarea id="promptInput" placeholder="Type your command..."></textarea>
  </div>

  <!-- Status Bar (appears below loading circle) -->
  <div class="status-bar" id="statusBar">
    <span class="status-bar-text" id="statusText">thinking</span>
    <div class="loading-dots">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>

  <!-- Instruction Box -->
  <div class="instruction-box" id="instructionBox" style="display: none;">
    <div class="instruction-header">
      <span id="instructionStep">Step 1 of 5</span>
      <button class="instruction-done-btn" id="instructionDoneBtn">Done</button>
    </div>
    <div class="instruction-body">
      <p id="instructionText">This is a placeholder for the instruction text. I will tell you what to do here.</p>
    </div>
    <div class="instruction-footer">
      <button class="instruction-nav-btn" id="instructionPrevBtn">&lt; Prev</button>
      <button class="instruction-nav-btn" id="instructionNextBtn">Next &gt;</button>
    </div>
  </div>

  <!-- Mouse Event Log -->
  <div class="event-log" id="eventLog">
    <div style="color: #00ff00; font-weight: bold; margin-bottom: 8px;">MOUSE EVENT LOG</div>
  </div>

  <script>
    const canvas = document.getElementById('overlay-canvas');
    const ctx = canvas.getContext('2d');
    const controlPanel = document.getElementById('controlPanel');
    const promptInput = document.getElementById('promptInput');
    const eventLog = document.getElementById('eventLog');

    // Auto-resize control panel based on textarea content
    const DEFAULT_HEIGHT = 60;
    const MAX_HEIGHT = 300; // Maximum height to prevent excessive expansion
    const LINE_HEIGHT = 20; // Line height from CSS
    const PADDING_VERTICAL = 40; // 20px top + 20px bottom
    const PILL_TO_RECT_THRESHOLD = 100; // Height at which to switch from pill to rectangle (~3 lines)
    const RECT_BORDER_RADIUS = 25; // Border radius when in rectangle mode

    function adjustControlPanelHeight() {
      // Skip if in loading state
      if (controlPanel.classList.contains('loading-text')) {
        return;
      }

      let finalHeight = DEFAULT_HEIGHT;

      // If empty, use default height
      if (!promptInput.value || promptInput.value.trim() === '') {
        controlPanel.style.height = DEFAULT_HEIGHT + 'px';
        promptInput.style.height = DEFAULT_HEIGHT + 'px';
      } else {
        // First check at current/default height if content is overflowing
        const currentHeight = parseInt(promptInput.style.height) || DEFAULT_HEIGHT;

        // Check if scrollHeight exceeds current height (content is cut off)
        const isOverflowing = promptInput.scrollHeight > currentHeight;

        if (isOverflowing) {
          // Content needs more space, measure actual requirement
          promptInput.style.height = 'auto';
          const scrollHeight = promptInput.scrollHeight;
          finalHeight = Math.min(scrollHeight, MAX_HEIGHT);

          controlPanel.style.height = finalHeight + 'px';
          promptInput.style.height = finalHeight + 'px';
        } else {
          // Content might fit in a smaller height, try default
          promptInput.style.height = DEFAULT_HEIGHT + 'px';

          // Check if it still fits
          if (promptInput.scrollHeight <= DEFAULT_HEIGHT) {
            // Fits in default, use it
            controlPanel.style.height = DEFAULT_HEIGHT + 'px';
            finalHeight = DEFAULT_HEIGHT;
          } else {
            // Doesn't fit in default, measure actual requirement
            promptInput.style.height = 'auto';
            const scrollHeight = promptInput.scrollHeight;
            finalHeight = Math.min(scrollHeight, MAX_HEIGHT);

            controlPanel.style.height = finalHeight + 'px';
            promptInput.style.height = finalHeight + 'px';
          }
        }
      }

      // Use pill shape for small heights, rectangle for larger
      if (finalHeight <= PILL_TO_RECT_THRESHOLD) {
        controlPanel.style.borderRadius = (finalHeight / 2) + 'px';
      } else {
        controlPanel.style.borderRadius = RECT_BORDER_RADIUS + 'px';
      }
    }

    // Set initial height explicitly
    controlPanel.style.height = DEFAULT_HEIGHT + 'px';
    promptInput.style.height = DEFAULT_HEIGHT + 'px';

    // Adjust height on input
    promptInput.addEventListener('input', adjustControlPanelHeight);

    // Prevent accidental quits on startup
    let quitButtonReady = false;
    setTimeout(() => {
      quitButtonReady = true;
      console.log('Quit button is now active');
    }, 1000);

    // Click capture mode
    let clickCaptureMode = false;

    // Set canvas size to physical screen size (for Retina displays)
    const devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = window.screen.width * devicePixelRatio;
    canvas.height = window.screen.height * devicePixelRatio;
    // Scale the canvas CSS to fit the logical screen size
    canvas.style.width = window.screen.width + 'px';
    canvas.style.height = window.screen.height + 'px';
    console.log('Canvas physical size:', canvas.width, 'x', canvas.height);
    console.log('Canvas CSS size:', canvas.style.width, 'x', canvas.style.height);

    let currentHighlight = null;
    let pulsePhase = 0;
    let animationId = null;
    const maxLogEntries = 50;

    // Spotlight circle state
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height / 2;
    const defaultCircleRadius = 40; // Smaller default

    // Tutorial mode variables
    let tutorialMode = false;
    let tutorialState = null; // Track full tutorial state
    let fixedSpotlightX = null;
    let fixedSpotlightY = null;
    let spotlightRadius = defaultCircleRadius; // Dynamic radius based on bbox
    let targetSpotlightRadius = defaultCircleRadius; // Target radius for animation
    let spotlightAnimationStart = 0; // Animation start time
    let spotlightAnimating = false;
    const SPOTLIGHT_ANIMATION_DURATION = 500; // ms for fly-out animation

    // Animation start/end positions (for fly-out from control panel)
    let animStartX = 0;
    let animStartY = 0;
    let animTargetX = 0;
    let animTargetY = 0;
    const ANIM_START_RADIUS = 30; // Start small from control panel
    let lastTargetClickTime = 0; // Debounce target clicks

    // Fade-out animation state
    let spotlightFadingOut = false;
    let spotlightFadeStart = 0;
    let spotlightOpacity = 1;
    const SPOTLIGHT_FADE_DURATION = 300; // ms for fade-out

    // Draw border to show overlay bounds
    function drawBorder() {
      ctx.strokeStyle = 'rgba(142, 142, 147, 0.3)';
      ctx.lineWidth = 2;
      ctx.setLineDash([10, 5]);
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.setLineDash([]);
    }

    // Draw spotlight circle - ONLY when in tutorial mode with a target
    let lastSpotlightLog = 0;
    function drawSpotlightCircle() {
      // Handle fade-out animation
      if (spotlightFadingOut) {
        const elapsed = Date.now() - spotlightFadeStart;
        const progress = Math.min(elapsed / SPOTLIGHT_FADE_DURATION, 1);
        // Ease out for smooth fade
        spotlightOpacity = 1 - progress;

        if (progress >= 1) {
          // Fade complete, fully clear spotlight
          spotlightFadingOut = false;
          tutorialMode = false;
          fixedSpotlightX = null;
          fixedSpotlightY = null;
          spotlightOpacity = 1;
          return;
        }
      }

      // Only draw if we're in tutorial mode with a valid target position
      if (!tutorialMode || fixedSpotlightX === null || fixedSpotlightY === null) {
        return; // Don't draw anything
      }
      if (Date.now() - lastSpotlightLog > 1000) {
        console.log('Drawing spotlight at:', fixedSpotlightX, fixedSpotlightY, 'radius:', spotlightRadius);
        lastSpotlightLog = Date.now();
      }

      const dpr = window.devicePixelRatio || 1;

      // Animate spotlight position and radius (fly-out from control panel)
      let currentRadius = spotlightRadius;
      let currentX = fixedSpotlightX;
      let currentY = fixedSpotlightY;

      if (spotlightAnimating) {
        const elapsed = Date.now() - spotlightAnimationStart;
        const progress = Math.min(elapsed / SPOTLIGHT_ANIMATION_DURATION, 1);
        // Ease-out exponential - fast start, slow approach to target
        const eased = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);

        // Animate position from control panel to target
        currentX = animStartX + (animTargetX - animStartX) * eased;
        currentY = animStartY + (animTargetY - animStartY) * eased;

        // Animate radius from small to target
        currentRadius = ANIM_START_RADIUS + (targetSpotlightRadius - ANIM_START_RADIUS) * eased;

        if (progress >= 1) {
          spotlightAnimating = false;
          spotlightRadius = targetSpotlightRadius;
          currentRadius = targetSpotlightRadius;
          currentX = animTargetX;
          currentY = animTargetY;
        }
      }

      // Make radius 15% bigger
      const displayRadius = currentRadius * 1.15;
      const featherSize = displayRadius * 0.3; // Soft edge feather amount

      // Draw dimmed overlay with soft feathered spotlight cutout
      ctx.save();

      // First fill the entire canvas with the dim color
      ctx.fillStyle = `rgba(0, 0, 0, ${0.65 * spotlightOpacity})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Now cut out the spotlight with a soft gradient edge
      ctx.globalCompositeOperation = 'destination-out';

      // Create radial gradient for soft edges
      const gradient = ctx.createRadialGradient(
        currentX, currentY, displayRadius - featherSize,
        currentX, currentY, displayRadius + featherSize
      );
      gradient.addColorStop(0, 'rgba(0, 0, 0, 1)'); // Fully transparent center
      gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)'); // Soft transition
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Blend to overlay

      ctx.beginPath();
      ctx.arc(currentX, currentY, displayRadius + featherSize, 0, 2 * Math.PI);
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.restore();

      // Add subtle inner glow (light glow inside the spotlight)
      ctx.save();
      const innerGlowGradient = ctx.createRadialGradient(
        currentX, currentY, 0,
        currentX, currentY, displayRadius
      );
      innerGlowGradient.addColorStop(0, `rgba(255, 255, 255, ${0.08 * spotlightOpacity})`);
      innerGlowGradient.addColorStop(0.7, `rgba(255, 255, 255, ${0.03 * spotlightOpacity})`);
      innerGlowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.beginPath();
      ctx.arc(currentX, currentY, displayRadius, 0, 2 * Math.PI);
      ctx.fillStyle = innerGlowGradient;
      ctx.fill();
      ctx.restore();

      // Draw soft organic halo - subtle and delicate
      const pulse = Math.sin(Date.now() / 400) * 0.1 + 0.9;

      // Soft outer glow - very subtle
      ctx.save();
      const outerGlow = ctx.createRadialGradient(
        currentX, currentY, displayRadius * 0.95,
        currentX, currentY, displayRadius * 1.12
      );
      outerGlow.addColorStop(0, 'rgba(255, 255, 255, 0)');
      outerGlow.addColorStop(0.4, `rgba(255, 255, 255, ${0.12 * pulse * spotlightOpacity})`);
      outerGlow.addColorStop(0.7, `rgba(255, 255, 255, ${0.06 * pulse * spotlightOpacity})`);
      outerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.beginPath();
      ctx.arc(currentX, currentY, displayRadius * 1.12, 0, 2 * Math.PI);
      ctx.fillStyle = outerGlow;
      ctx.fill();
      ctx.restore();

      // Soft diffuse ring - gentle glow at the edge
      ctx.save();
      const ringGlow = ctx.createRadialGradient(
        currentX, currentY, displayRadius * 0.92,
        currentX, currentY, displayRadius * 1.12
      );
      ringGlow.addColorStop(0, 'rgba(255, 255, 255, 0)');
      ringGlow.addColorStop(0.3, `rgba(255, 255, 255, ${0.08 * pulse * spotlightOpacity})`);
      ringGlow.addColorStop(0.5, `rgba(255, 255, 255, ${0.15 * pulse * spotlightOpacity})`);
      ringGlow.addColorStop(0.7, `rgba(255, 255, 255, ${0.08 * pulse * spotlightOpacity})`);
      ringGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');

      ctx.beginPath();
      ctx.arc(currentX, currentY, displayRadius * 1.12, 0, 2 * Math.PI);
      ctx.fillStyle = ringGlow;
      ctx.fill();
      ctx.restore();
    }

    function drawHighlight(bbox, instruction) {
      currentHighlight = {
        bbox,
        instruction,
        startTime: Date.now() // Track when we started showing this
      };
      if (!animationId) {
        animate();
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Always draw border
      drawBorder();

      // Draw spotlight circle if in tutorial mode
      drawSpotlightCircle();

      if (!currentHighlight) {
        animationId = requestAnimationFrame(animate);
        return;
      }

      const { bbox, instruction } = currentHighlight;
      const [x1, y1, x2, y2] = bbox;
      const w = x2 - x1;
      const h = y2 - y1;

      // Pulsing glow effect
      pulsePhase += 0.1;
      const pulse = Math.sin(pulsePhase) * 0.3 + 0.7;
      const glowSize = 10 + Math.sin(pulsePhase) * 5;

      // Outer glow
      ctx.shadowColor = `rgba(142, 142, 147, ${pulse})`;
      ctx.shadowBlur = glowSize;
      ctx.strokeStyle = '#8e8e93';
      ctx.lineWidth = 3;
      ctx.strokeRect(x1 - 5, y1 - 5, w + 10, h + 10);

      // Inner highlight
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(142, 142, 147, 0.1)';
      ctx.fillRect(x1, y1, w, h);

      // Instruction tooltip
      if (instruction) {
        const tooltipY = y2 + 15;
        const textWidth = ctx.measureText(instruction).width;
        const boxWidth = Math.max(200, textWidth + 20);
        const boxHeight = 40;
        const boxX = x1;

        // Arrow pointing to element
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.beginPath();
        ctx.moveTo(x1 + w / 2, y2 + 5);
        ctx.lineTo(x1 + w / 2 - 8, y2 + 15);
        ctx.lineTo(x1 + w / 2 + 8, y2 + 15);
        ctx.closePath();
        ctx.fill();

        // Tooltip box
        ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
        ctx.beginPath();
        ctx.roundRect(boxX, tooltipY, boxWidth, boxHeight, 6);
        ctx.fill();

        // Tooltip text
        ctx.fillStyle = '#ffffff';
        ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        // Tooltip text - with typing effect
        const typingSpeed = 30; // ms per char
        const elapsed = Date.now() - (instruction ? currentHighlight.startTime : 0);
        const charsToShow = Math.floor(elapsed / typingSpeed);
        const textToDisplay = instruction.substring(0, charsToShow);

        ctx.fillStyle = '#ffffff';
        ctx.font = '14px -apple-system, BlinkMacSystemFont, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(textToDisplay, boxX + 10, tooltipY + boxHeight / 2);

        // Cursor effect for tooltip
        if (charsToShow < instruction.length) {
          const measuredWidth = ctx.measureText(textToDisplay).width;
          if (Math.floor(Date.now() / 500) % 2 === 0) {
            ctx.fillRect(boxX + 10 + measuredWidth + 2, tooltipY + boxHeight / 2 - 7, 2, 14);
          }
        }
      }

      animationId = requestAnimationFrame(animate);
    }

    function clearHighlight() {
      currentHighlight = null;
    }

    // Mouse event logging
    function logEvent(eventType, data) {
      const timestamp = new Date().toLocaleTimeString('en-US', {
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3
      });

      const entry = document.createElement('div');
      entry.className = 'event-log-entry';

      let logText = `<span class="timestamp">${timestamp}</span> `;
      logText += `<span class="event-type">${eventType.padEnd(12)}</span> `;

      if (data.x !== undefined && data.y !== undefined) {
        logText += `<span class="coords">x:${Math.round(data.x).toString().padStart(4)} y:${Math.round(data.y).toString().padStart(4)}</span>`;
      }

      if (data.button !== undefined && data.button !== null) {
        const buttonNames = { 0: 'LEFT', 1: 'LEFT', 2: 'RIGHT', 3: 'MIDDLE' };
        const btnName = data.buttonName || buttonNames[data.button] || data.button;
        logText += ` btn:${btnName}`;
      }

      if (data.deltaX || data.deltaY) {
        logText += ` Δx:${Math.round(data.deltaX)} Δy:${Math.round(data.deltaY)}`;
      }

      entry.innerHTML = logText;

      // Add to top of log
      const firstEntry = eventLog.querySelector('.event-log-entry');
      if (firstEntry) {
        eventLog.insertBefore(entry, firstEntry);
      } else {
        eventLog.appendChild(entry);
      }

      // Limit log entries
      const entries = eventLog.querySelectorAll('.event-log-entry');
      if (entries.length > maxLogEntries) {
        entries[entries.length - 1].remove();
      }
    }

    // Listen for highlight commands
    if (window.overlayAPI) {
      window.overlayAPI.onHighlight((bbox, instruction) => {
        console.log('Highlighting:', bbox, instruction);
        drawHighlight(bbox, instruction);
      });

      window.overlayAPI.onClearHighlight(() => {
        console.log('Clearing highlight');
        clearHighlight();
      });
    }

    // Listen for mouse events directly from DOM (when over our UI)
    document.addEventListener('mousemove', (e) => {
      if (!window.lastMoveLog || Date.now() - window.lastMoveLog > 100) {
        logEvent('mouse-move [DOM]', { x: e.screenX, y: e.screenY });
        window.lastMoveLog = Date.now();
      }
    });

    document.addEventListener('mousedown', (e) => {
      logEvent('mouse-down [DOM]', { x: e.screenX, y: e.screenY, button: e.button });
    });

    document.addEventListener('mouseup', (e) => {
      logEvent('mouse-up [DOM]', { x: e.screenX, y: e.screenY, button: e.button });
    });

    document.addEventListener('click', (e) => {
      logEvent('click [DOM]', { x: e.screenX, y: e.screenY, button: e.button });
    });

    document.addEventListener('dblclick', (e) => {
      logEvent('double-click [DOM]', { x: e.screenX, y: e.screenY, button: e.button });
    });

    document.addEventListener('contextmenu', (e) => {
      logEvent('right-click [DOM]', { x: e.screenX, y: e.screenY });
    });

    document.addEventListener('wheel', (e) => {
      logEvent('scroll [DOM]', { x: e.screenX, y: e.screenY, deltaX: e.deltaX, deltaY: e.deltaY });
    });

    // Listen for global mouse events from main process (works even when clicking other apps)
    if (window.electronAPI) {
      // Listen for fixed spotlight position from main process (tutorial mode)
      console.log('Setting up onSetSpotlightPosition listener:', !!window.electronAPI.onSetSpotlightPosition);
      const dpr = window.devicePixelRatio || 1;
      console.log('Device pixel ratio:', dpr, 'Canvas:', canvas.width, 'x', canvas.height);
      console.log('Screen:', window.screen.width, 'x', window.screen.height);

      if (window.electronAPI.onSetSpotlightPosition) {
        window.electronAPI.onSetSpotlightPosition((data) => {
          console.log('=== SPOTLIGHT POSITION RECEIVED ===', data);
          logEvent('SPOTLIGHT', { coords: data ? `${data.x},${data.y}` : 'null' });
          if (data) {
            tutorialMode = true;
            // Use coordinates directly (already in physical pixel space)
            fixedSpotlightX = data.x;
            fixedSpotlightY = data.y;

            // Calculate radius from bounding box if available
            if (data.bbox && Array.isArray(data.bbox) && data.bbox.length === 4) {
              const [x1, y1, x2, y2] = data.bbox;
              const bboxWidth = Math.abs(x2 - x1);
              const bboxHeight = Math.abs(y2 - y1);
              // Use the larger dimension + padding for circle radius, with minimum
              const calcRadius = Math.max(bboxWidth, bboxHeight) / 2 + 20;
              targetSpotlightRadius = Math.max(calcRadius, 50); // Minimum 50px radius
              console.log('Bbox:', data.bbox, 'Size:', bboxWidth, 'x', bboxHeight, 'Target Radius:', targetSpotlightRadius);
            } else {
              // Fallback to default radius scaled for Retina
              targetSpotlightRadius = defaultCircleRadius * dpr;
              console.log('No bbox, using default radius:', targetSpotlightRadius);
            }

            // Calculate control panel center (start position for fly-out animation)
            // Control panel: top: 20px, right: 20px, width: 420px, height: 60px
            const controlPanelCenterX = (window.innerWidth - 20 - 210) * dpr; // right edge - margin - half width
            const controlPanelCenterY = (20 + 30) * dpr; // top margin + half height

            // Set animation start (from control panel) and target positions
            animStartX = controlPanelCenterX;
            animStartY = controlPanelCenterY;
            animTargetX = data.x;
            animTargetY = data.y;

            // Start fly-out animation
            spotlightAnimating = true;
            spotlightAnimationStart = Date.now();
            spotlightRadius = ANIM_START_RADIUS; // Start small

            console.log('Tutorial mode: ON, flying from', animStartX, animStartY, 'to', animTargetX, animTargetY, 'radius:', targetSpotlightRadius);
          } else {
            // Start fade-out animation instead of instant clear
            if (tutorialMode && !spotlightFadingOut) {
              spotlightFadingOut = true;
              spotlightFadeStart = Date.now();
              spotlightAnimating = false;
              console.log('Tutorial mode: fading out...');
            } else if (!tutorialMode) {
              // Already off, just reset
              spotlightRadius = defaultCircleRadius * dpr;
              targetSpotlightRadius = defaultCircleRadius * dpr;
              console.log('Tutorial mode: already OFF');
            }
          }
        });
      } else {
        console.error('onSetSpotlightPosition not available in electronAPI!');
      }

      // Listen for tutorial state changes
      if (window.electronAPI.onTutorialStateChange) {
        window.electronAPI.onTutorialStateChange((state) => {
          console.log('Tutorial state changed:', state);
          updateUIForState(state);
        });
      }

      // Global mouse move
      if (window.electronAPI.onGlobalMouseMove) {
        window.electronAPI.onGlobalMouseMove((event) => {
          // Only update spotlight position if NOT in tutorial mode
          if (!tutorialMode) {
            mouseX = event.position.x;
            mouseY = event.position.y;
          }

          if (!window.lastGlobalMoveLog || Date.now() - window.lastGlobalMoveLog > 100) {
            logEvent('mouse-move [GLOBAL]', { x: event.position.x, y: event.position.y });
            window.lastGlobalMoveLog = Date.now();
          }
        });
      }

      // Global mouse down
      if (window.electronAPI.onGlobalMouseDown) {
        window.electronAPI.onGlobalMouseDown((event) => {
          const buttonNames = { 1: 'LEFT', 2: 'RIGHT', 3: 'MIDDLE' };
          logEvent('mouse-down [GLOBAL]', {
            x: event.position.x,
            y: event.position.y,
            button: event.button,
            buttonName: buttonNames[event.button]
          });
        });
      }

      // Global mouse up
      if (window.electronAPI.onGlobalMouseUp) {
        window.electronAPI.onGlobalMouseUp((event) => {
          const buttonNames = { 1: 'LEFT', 2: 'RIGHT', 3: 'MIDDLE' };
          logEvent('mouse-up [GLOBAL]', {
            x: event.position.x,
            y: event.position.y,
            button: event.button,
            buttonName: buttonNames[event.button]
          });
        });
      }

      // Global click
      if (window.electronAPI.onGlobalClick) {
        window.electronAPI.onGlobalClick((event) => {
          const buttonNames = { 1: 'LEFT', 2: 'RIGHT', 3: 'MIDDLE' };
          logEvent('click [GLOBAL]', {
            x: event.position.x,
            y: event.position.y,
            button: event.button,
            buttonName: buttonNames[event.button],
            clicks: event.clicks
          });

          // Check if click happened while in tutorial mode - advance to next step
          if (tutorialMode && fixedSpotlightX !== null && fixedSpotlightY !== null) {
            // Debounce: ignore clicks within 200ms of last target click (prevent double-fire)
            const now = Date.now();
            if ((now - lastTargetClickTime) > 200) {
              lastTargetClickTime = now;
              console.log('Click detected in tutorial mode, advancing to next step...');
              logEvent('TARGET_CLICK', { x: event.position.x, y: event.position.y });
              window.electronAPI.notifyTargetClicked();
            }
          }
        });
      }

      // Global scroll
      if (window.electronAPI.onGlobalScroll) {
        window.electronAPI.onGlobalScroll((event) => {
          logEvent('scroll [GLOBAL]', {
            x: event.position.x,
            y: event.position.y,
            rotation: event.rotation,
            direction: event.direction
          });
        });
      }
    }

    // Control panel interactivity
    const controlRect = controlPanel.getBoundingClientRect();

    // Disable click-through when over control panel
    controlPanel.addEventListener('mouseenter', () => {
      if (window.electronAPI) {
        window.electronAPI.send('set-click-through', false);
      }
    });

    controlPanel.addEventListener('mouseleave', () => {
      if (window.electronAPI) {
        window.electronAPI.send('set-click-through', true);
      }
    });

    // Loading animation states - fun cycling words (Planning always first)
    const loadingMessages = [
      'Planning',      // Always starts here
      'Thinking',
      'Hmm',
      'Pondering',
      'Mapping',
      'Pfft',
      'Computing',
      'Vibing',
      'Processing',
      'Brewing',
      'Scheming',
      'Crunching',
      'Noodling',
      'Conjuring',
      'Mulling',
      'Calibrating',
      'Imagining',
      'Simmering'
    ];
    let loadingCycleCount = 0;
    let loadingTimeout = null;
    let messageIndex = 0;
    let isLoadingActive = false;
    let loadingCharIndex = 0;
    let loadingTypeInterval = null;
    const loadingTextDisplay = document.getElementById('loadingTextDisplay');

    function typeLoadingText(text, onComplete) {
      loadingCharIndex = 0;
      loadingTextDisplay.textContent = '';

      if (loadingTypeInterval) {
        clearInterval(loadingTypeInterval);
      }

      loadingTypeInterval = setInterval(() => {
        if (loadingCharIndex < text.length) {
          loadingTextDisplay.textContent = text.substring(0, loadingCharIndex + 1) + '...';
          loadingCharIndex++;
        } else {
          clearInterval(loadingTypeInterval);
          loadingTypeInterval = null;
          if (onComplete) onComplete();
        }
      }, 60); // 60ms per character
    }

    function animateLoadingCycle() {
      if (!isLoadingActive) return;

      const currentMessage = loadingMessages[messageIndex];

      typeLoadingText(currentMessage, () => {
        // Wait a bit after typing completes, then move to next word
        loadingTimeout = setTimeout(() => {
          if (!isLoadingActive) return;
          loadingCycleCount++;
          // After "Planning", randomly pick from the rest (index 1 onwards)
          messageIndex = 1 + Math.floor(Math.random() * (loadingMessages.length - 1));
          animateLoadingCycle();
        }, 2500); // Show each word for 2.5s after typing completes
      });
    }

    function startLoadingAnimation() {
      loadingCycleCount = 0;
      messageIndex = 0; // Always start with "Planning"
      isLoadingActive = true;
      promptInput.value = '';
      promptInput.readOnly = true;

      // Show loading pill with text - explicitly set dimensions
      controlPanel.style.width = '150px';
      controlPanel.style.height = '50px';
      controlPanel.style.borderRadius = '25px';
      controlPanel.classList.add('loading-text');

      animateLoadingCycle();
    }

    function stopLoadingAnimation() {
      isLoadingActive = false;
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
        loadingTimeout = null;
      }
      if (loadingTypeInterval) {
        clearInterval(loadingTypeInterval);
        loadingTypeInterval = null;
      }
      controlPanel.classList.remove('loading-text');
      loadingTextDisplay.textContent = '';

      // Reset to default dimensions
      controlPanel.style.height = DEFAULT_HEIGHT + 'px';
      controlPanel.style.width = '420px';
      controlPanel.style.borderRadius = '30px';
      promptInput.value = '';
      promptInput.readOnly = false;
      promptInput.focus();

      // Adjust height after a brief delay
      setTimeout(adjustControlPanelHeight, 50);
    }

    // Submit on Enter key
    promptInput.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault(); // Prevent new line
        const prompt = promptInput.value.trim();
        if (!prompt) return;

        console.log('Starting tutorial:', prompt);
        logEvent('USER_ACTION', { message: 'Start tutorial: ' + prompt });

        // Start loading animation
        startLoadingAnimation();

        promptInput.disabled = true;
        promptInput.placeholder = 'Planning...';

        try {
          const result = await window.electronAPI.startTutorial(prompt);
          stopLoadingAnimation();
          if (!result.success) {
            console.error('Tutorial failed:', result.error);
            logEvent('ERROR', { message: result.error });
            promptInput.disabled = false;
            promptInput.placeholder = 'Type your command...';
          }
        } catch (error) {
          stopLoadingAnimation();
          console.error('Tutorial error:', error);
          logEvent('ERROR', { message: error.message || 'Unknown error' });
          promptInput.disabled = false;
          promptInput.placeholder = 'Type your command...';
        }

        // Clear the input after submitting
        promptInput.value = '';
      }
    });

    // Update UI based on tutorial state
    function updateUIForState(state) {
      let placeholderText = '';

      // Stop loading animation when we have an actual state to show
      if (state.mode === 'highlighting' || state.mode === 'complete' || state.mode === 'error') {
        stopLoadingAnimation();
      }

      switch (state.mode) {
        case 'idle':
          promptInput.disabled = false;
          placeholderText = 'Type your command...';
          break;
        case 'planning':
          promptInput.disabled = true;
          placeholderText = 'Planning...';
          break;
        case 'locating':
          promptInput.disabled = true;
          placeholderText = 'Finding element...';
          break;
        case 'highlighting':
          promptInput.disabled = true;
          if (state.plan && state.plan.steps && state.plan.steps[state.currentStepIndex]) {
            const step = state.plan.steps[state.currentStepIndex];
            placeholderText = `Step ${state.currentStepIndex + 1}: ${step.instruction}`;
          } else {
            placeholderText = `Step ${state.currentStepIndex + 1}: Click the target`;
          }
          break;
        case 'complete':
          promptInput.disabled = false;
          placeholderText = 'Done! Type next command...';
          tutorialMode = false;
          fixedSpotlightX = null;
          fixedSpotlightY = null;
          logEvent('TUTORIAL', { message: 'Tutorial completed!' });
          break;
        case 'error':
          promptInput.disabled = false;
          placeholderText = 'Type your command...';
          if (state.error) {
            logEvent('ERROR', { message: state.error });
          }
          break;
      }

      // Toggle glow effect based on state logic
      if (state.mode === 'planning' || state.mode === 'locating') {
        controlPanel.classList.add('state-processing');
      } else {
        controlPanel.classList.remove('state-processing');
      }

      // Stop any existing typewriter on the input
      stopTypewriter('input_placeholder');


      // Start typing effect if there is text
      if (placeholderText) {
        // Clear it first
        promptInput.placeholder = '';

        startTypewriter('input_placeholder', placeholderText, (text) => {
          promptInput.placeholder = text;
          adjustHeightForPlaceholder(text);
        });
      } else {
        promptInput.placeholder = '';
        adjustHeightForPlaceholder('');
      }

    }

    // Adjust height based on placeholder text length
    function adjustHeightForPlaceholder(text) {
      let finalHeight = DEFAULT_HEIGHT;

      if (!text) {
        controlPanel.style.height = DEFAULT_HEIGHT + 'px';
        promptInput.style.height = DEFAULT_HEIGHT + 'px';
      } else {
        // Create temporary element to measure text height
        const temp = document.createElement('div');
        temp.style.position = 'absolute';
        temp.style.visibility = 'hidden';
        temp.style.width = (420 - 50) + 'px'; // Control panel width minus horizontal padding (25px each side)
        temp.style.fontSize = '16px';
        temp.style.lineHeight = '20px';
        temp.style.fontFamily = '"SF Pro Display", -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif';
        temp.style.whiteSpace = 'pre-wrap';
        temp.style.wordWrap = 'break-word';
        temp.textContent = text;
        document.body.appendChild(temp);

        const textHeight = temp.offsetHeight;
        document.body.removeChild(temp);

        // Calculate required height with padding (20px top + 20px bottom = 40px)
        finalHeight = Math.min(Math.max(textHeight + PADDING_VERTICAL, DEFAULT_HEIGHT), MAX_HEIGHT);

        controlPanel.style.height = finalHeight + 'px';
        promptInput.style.height = finalHeight + 'px';
      }

      // Use pill shape for small heights, rectangle for larger
      if (finalHeight <= PILL_TO_RECT_THRESHOLD) {
        controlPanel.style.borderRadius = (finalHeight / 2) + 'px';
      } else {
        controlPanel.style.borderRadius = RECT_BORDER_RADIUS + 'px';
      }
    }



    // Click capture toggle - DISABLED (captureToggle element doesn't exist)
    // captureToggle.addEventListener('change', () => {
    //   clickCaptureMode = captureToggle.checked;
    //   console.log('Click capture mode:', clickCaptureMode);
    //   logEvent('SYSTEM', { message: `Click capture mode: ${clickCaptureMode ? 'ON' : 'OFF'}` });
    //
    //   // When enabled, disable click-through globally to capture all clicks on overlay
    //   if (window.electronAPI) {
    //     window.electronAPI.send('set-click-through', !clickCaptureMode);
    //   }
    // });

    // Start animation loop to show border
    animate();

    // Typewriter effect handler
    const activeTypewriters = {};

    function startTypewriter(id, text, callback, speed = 30) {
      // Clear existing typewriter for this ID
      if (activeTypewriters[id]) {
        clearInterval(activeTypewriters[id].interval);
      }

      let i = 0;
      activeTypewriters[id] = {
        interval: setInterval(() => {
          if (i < text.length) {
            callback(text.substring(0, i + 1));
            i++;
          } else {
            clearInterval(activeTypewriters[id].interval);
            delete activeTypewriters[id];
          }
        }, speed),
        fullText: text
      };

      // Initial empty state
      callback('');
    }

    function stopTypewriter(id) {
      if (activeTypewriters[id]) {
        clearInterval(activeTypewriters[id].interval);
        delete activeTypewriters[id];
      }
    }

    // Position toggle state
    let isBottomPosition = false;

    // Toggle control panel position with Shift+Ctrl+ArrowDown
    document.addEventListener('keydown', (e) => {
      if (e.shiftKey && e.ctrlKey && e.key === 'ArrowDown') {
        e.preventDefault();
        isBottomPosition = !isBottomPosition;

        if (isBottomPosition) {
          controlPanel.classList.add('position-bottom');
          console.log('Control panel moved to bottom-right (expands upward)');
          logEvent('POSITION', { message: 'Moved to bottom-right' });
        } else {
          controlPanel.classList.remove('position-bottom');
          console.log('Control panel moved to top-right (expands downward)');
          logEvent('POSITION', { message: 'Moved to top-right' });
        }
      }
    });

    // Auto-focus the input field on load
    promptInput.focus();

    console.log('Overlay loaded. Canvas size:', canvas.width, 'x', canvas.height);
    console.log('Tutorial integration ready.');
  </script>
</body>

</html>